Steven Millett
MSDS 3606


> swirl()

| Welcome to swirl! Please sign in. If you've been here before, use the same name as
| you did then. If you are new, call yourself something unique.

What shall I call you? Steven

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files     
 3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times         
15: Base Graphics             

Selection: 8

  |                                                                           |   0%

| This lesson is meant to be a short introduction to logical operations in R.

...

  |=                                                                          |   2%

| There are two logical values in R, also called boolean values. They are TRUE and
| FALSE. In R you can construct logical expressions which will evaluate to either
| TRUE or FALSE.

...

  |===                                                                        |   4%

| Many of the questions in this lesson will involve evaluating logical expressions.
| It may be useful to open up a second R terminal where you can experiment with some
| of these expressions.

...

  |====                                                                       |   6%

| Creating logical expressions requires logical operators. You're probably familiar
| with arithmetic operators like `+`, `-`, `*`, and `/`. The first logical operator
| we are going to discuss is the equality operator, represented by two equals signs
| `==`. Use the equality operator below to find out if TRUE is equal to TRUE.

> 
> TRUE == TRUE
[1] TRUE

| That's the answer I was looking for.

  |======                                                                     |   8%

| Just like arithmetic, logical expressions can be grouped by parenthesis so that
| the entire expression (TRUE == TRUE) == TRUE evaluates to TRUE.

...

  |=======                                                                    |  10%

| To test out this property, try evaluating (FALSE == TRUE) == FALSE .

> (FALSE == TRUE) == FALSE
[1] TRUE

| Nice work!

  |=========                                                                  |  12%

| The equality operator can also be used to compare numbers. Use `==` to see if 6 is
| equal to 7.

> 6 == 7
[1] FALSE

| You are doing so well!

  |==========                                                                 |  13%

| The previous expression evaluates to FALSE because 6 is less than 7. Thankfully,
| there are inequality operators that allow us to test if a value is less than or
| greater than another value.

...

  |============                                                               |  15%

| The less than operator `<` tests whether the number on the left side of the
| operator (called the left operand) is less than the number on the right side of
| the operator (called the right operand). Write an expression to test whether 6 is
| less than 7.

> 6 < 7
[1] TRUE

| You nailed it! Good job!

  |=============                                                              |  17%

| There is also a less-than-or-equal-to operator `<=` which tests whether the left
| operand is less than or equal to the right operand. Write an expression to test
| whether 10 is less than or equal to 10.

> 10 <= 10
[1] TRUE

| Excellent work!

  |==============                                                             |  19%

| Keep in mind that there are the corresponding greater than `>` and
| greater-than-or-equal-to `>=` operators.

...

  |================                                                           |  21%

| Which of the following evaluates to FALSE?

1: 9 >= 10
2: 6 < 8
3: 7 == 7
4: 0 > -36

Selection: 1

| Excellent work!

  |=================                                                          |  23%

| Which of the following evaluates to TRUE?

1: 9 >= 10
2: 7 == 9
3: 57 < 8
4: -6 > -7

Selection: 4

| All that practice is paying off!

  |===================                                                        |  25%

| The next operator we will discuss is the 'not equals' operator represented by
| `!=`. Not equals tests whether two values are unequal, so TRUE != FALSE evaluates
| to TRUE. Like the equality operator, `!=` can also be used with numbers. Try
| writing an expression to see if 5 is not equal to 7.

> 
> TRUE != FALSE
[1] TRUE

| Not quite, but you're learning! Try again. Or, type info() for more options.

| Use the not equals operator and type 5 != 7

> 5 != 7
[1] TRUE

| That's correct!

  |====================                                                       |  27%

| In order to negate boolean expressions you can use the NOT operator. An
| exclamation point `!` will cause !TRUE (say: not true) to evaluate to FALSE and
| !FALSE (say: not false) to evaluate to TRUE. Try using the NOT operator and the
| equals operator to find the opposite of whether 5 is equal to 7.

> !(5 = 7)
Error in 5 = 7 : invalid (do_set) left-hand side to assignment
> !(5 == 7)
[1] TRUE

| You are really on a roll!

  |======================                                                     |  29%

| Let's take a moment to review. The equals operator `==` tests whether two boolean
| values or numbers are equal, the not equals operator `!=` tests whether two
| boolean values or numbers are unequal, and the NOT operator `!` negates logical
| expressions so that TRUE expressions become FALSE and FALSE expressions become
| TRUE.

...

  |=======================                                                    |  31%

| Which of the following evaluates to FALSE?

1: 9 < 10
2: !(0 >= -1)
3: !FALSE
4: 7 != 8

Selection: 2

| You are quite good my friend!

  |=========================                                                  |  33%

| What do you think the following expression will evaluate to?: (TRUE != FALSE) ==
| !(6 == 7)

1: %>%
2: TRUE
3: Can there be objective truth when programming?
4: FALSE

Selection: 2

| You got it!

  |==========================                                                 |  35%

| At some point you may need to examine relationships between multiple logical
| expressions. This is where the AND operator and the OR operator come in.

...

  |===========================                                                |  37%

| Let's look at how the AND operator works. There are two AND operators in R, `&`
| and `&&`. Both operators work similarly, if the right and left operands of AND are
| both TRUE the entire expression is TRUE, otherwise it is FALSE. For example, TRUE
| & TRUE evaluates to TRUE. Try typing FALSE & FALSE to how it is evaluated.

> FALSE & FALSE
[1] FALSE

| Perseverance, that's the answer.

  |=============================                                              |  38%

| You can use the `&` operator to evaluate AND across a vector. The `&&` version of
| AND only evaluates the first member of a vector. Let's test both for practice.
| Type the expression TRUE & c(TRUE, FALSE, FALSE).

> TRUE & c(TRUE, FALSE, FALSE)
[1]  TRUE FALSE FALSE

| That's correct!

  |==============================                                             |  40%

| What happens in this case is that the left operand `TRUE` is recycled across every
| element in the vector of the right operand. This is the equivalent statement as
| c(TRUE, TRUE, TRUE) & c(TRUE, FALSE, FALSE).

...

  |================================                                           |  42%

| Now we'll type the same expression except we'll use the `&&` operator. Type the
| expression TRUE && c(TRUE, FALSE, FALSE).

> TRUE && c(TRUE, FALSE, FALSE)
[1] TRUE

| Excellent job!

  |=================================                                          |  44%

| In this case, the left operand is only evaluated with the first member of the
| right operand (the vector). The rest of the elements in the vector aren't
| evaluated at all in this expression.

...

  |===================================                                        |  46%

| The OR operator follows a similar set of rules. The `|` version of OR evaluates OR
| across an entire vector, while the `||` version of OR only evaluates the first
| member of a vector.

...

  |====================================                                       |  48%

| An expression using the OR operator will evaluate to TRUE if the left operand or
| the right operand is TRUE. If both are TRUE, the expression will evaluate to TRUE,
| however if neither are TRUE, then the expression will be FALSE.

...

  |======================================                                     |  50%

| Let's test out the vectorized version of the OR operator. Type the expression TRUE
| | c(TRUE, FALSE, FALSE).

> TRUE | c(TRUE, FALSE, FALSE)
[1] TRUE TRUE TRUE

| Excellent work!

  |=======================================                                    |  52%

| Now let's try out the non-vectorized version of the OR operator. Type the
| expression TRUE || c(TRUE, FALSE, FALSE).

> TRUE || c(TRUE, FALSE, FALSE)
[1] TRUE

| Great job!

  |========================================                                   |  54%

| Logical operators can be chained together just like arithmetic operators. The
| expressions: `6 != 10 && FALSE && 1 >= 2` or `TRUE || 5 < 9.3 || FALSE` are
| perfectly normal to see.

...

  |==========================================                                 |  56%

| As you may recall, arithmetic has an order of operations and so do logical
| expressions. All AND operators are evaluated before OR operators. Let's look at an
| example of an ambiguous case. Type: 5 > 8 || 6 != 8 && 4 > 3.9

> 5 > 8 || 6 != 8 && 4 > 3.9
[1] TRUE

| Your dedication is inspiring!

  |===========================================                                |  58%

| Let's walk through the order of operations in the above case. First the left and
| right operands of the AND operator are evaluated. 6 is not equal 8, 4 is greater
| than 3.9, therefore both operands are TRUE so the resulting expression `TRUE &&
| TRUE` evaluates to TRUE. Then the left operand of the OR operator is evaluated: 5
| is not greater than 8 so the entire expression is reduced to FALSE || TRUE. Since
| the right operand of this expression is TRUE the entire expression evaluates to
| TRUE.

...

  |=============================================                              |  60%

| Which one of the following expressions evaluates to TRUE?

1: 99.99 > 100 || 45 < 7.3 || 4 != 4.0
2: FALSE || TRUE && FALSE
3: TRUE && 62 < 62 && 44 >= 44
4: TRUE && FALSE || 9 >= 4 && 3 < 6

Selection: 4

| All that practice is paying off!

  |==============================================                             |  62%

| Which one of the following expressions evaluates to FALSE?

1: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
2: 6 >= -9 && !(6 > 7) && !(!TRUE)
3: FALSE || TRUE && 6 != 4 || 9 > 4
4: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5

Selection: 2

| Not quite, but you're learning! Try again.

| Try to evaluate each expression in isolation and build up an answer.

1: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
2: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
3: 6 >= -9 && !(6 > 7) && !(!TRUE)
4: FALSE || TRUE && 6 != 4 || 9 > 4

Selection: 1

| You got it!

  |================================================                           |  63%

| Now that you're familiar with R's logical operators you can take advantage of a
| few functions that R provides for dealing with logical expressions.

...

  |=================================================                          |  65%

| The function isTRUE() takes one argument. If that argument evaluates to TRUE, the
| function will return TRUE. Otherwise, the function will return FALSE. Try using
| this function by typing: isTRUE(6 > 4)

> isTRUE(6 > 4)
[1] TRUE

| You are quite good my friend!

  |==================================================                         |  67%

| Which of the following evaluates to TRUE?

1: !isTRUE(4 < 3)
2: !isTRUE(8 != 5)
3: isTRUE(NA)
4: isTRUE(!TRUE)
5: isTRUE(3)

Selection: 1

| You are doing so well!

  |====================================================                       |  69%

| The function identical() will return TRUE if the two R objects passed to it as
| arguments are identical. Try out the identical() function by typing:
| identical('twins', 'twins')

> identical('twins', 'twins')
[1] TRUE

| That's correct!

  |=====================================================                      |  71%

| Which of the following evaluates to TRUE?

1: identical(4, 3.1)
2: !identical(7, 7)
3: identical(5 > 4, 3 < 3.1)
4: identical('hello', 'Hello')

Selection: identical('hello', 'hello')
Enter an item from the menu, or 0 to exit
Selection: 4

| Keep trying!

| identical() will only evaluate to TRUE if its arguments are exactly the same.

1: identical(4, 3.1)
2: identical(5 > 4, 3 < 3.1)
3: identical('hello', 'Hello')
4: !identical(7, 7)

Selection: 3

| Not exactly. Give it another go.

| identical() will only evaluate to TRUE if its arguments are exactly the same.

1: identical(5 > 4, 3 < 3.1)
2: identical('hello', 'Hello')
3: identical(4, 3.1)
4: !identical(7, 7)

Selection: 1

| All that hard work is paying off!

  |=======================================================                    |  73%

| You should also be aware of the xor() function, which takes two arguments. The
| xor() function stands for exclusive OR. If one argument evaluates to TRUE and one
| argument evaluates to FALSE, then this function will return TRUE, otherwise it
| will return FALSE. Try out the xor() function by typing: xor(5 == 6, !FALSE)

> xor(5 == 6, !FALSE)
[1] TRUE

| You got it right!

  |========================================================                   |  75%

| 5 == 6 evaluates to FALSE, !FALSE evaluates to TRUE, so xor(FALSE, TRUE) evaluates
| to TRUE. On the other hand if the first argument was changed to 5 == 5 and the
| second argument was unchanged then both arguments would have been TRUE, so
| xor(TRUE, TRUE) would have evaluated to FALSE.

...

  |==========================================================                 |  77%

| Which of the following evaluates to FALSE?

1: xor(!!TRUE, !!FALSE)
2: xor(!isTRUE(TRUE), 6 > -1)
3: xor(4 >= 9, 8 != 8.0)
4: xor(identical(xor, 'xor'), 7 == 7.0)

Selection: 3

| You nailed it! Good job!

  |===========================================================                |  79%

| For the next few questions, we're going to need to create a vector of integers
| called ints. Create this vector by typing: ints <- sample(10)

> ints <- sample(10)

| All that practice is paying off!

  |=============================================================              |  81%

| Now simply display the contents of ints.

> ints
 [1]  5  6  1 10  4  2  3  9  8  7

| You are really on a roll!

  |==============================================================             |  83%

| The vector `ints` is a random sampling of integers from 1 to 10 without
| replacement. Let's say we wanted to ask some logical questions about contents of
| ints. If we type ints > 5, we will get a logical vector corresponding to whether
| each element of ints is greater than 5. Try typing: ints > 5

> ints > 5
 [1] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE

| You're the best!

  |===============================================================            |  85%

| We can use the resulting logical vector to ask other questions about ints. The
| which() function takes a logical vector as an argument and returns the indices of
| the vector that are TRUE. For example which(c(TRUE, FALSE, TRUE)) would return the
| vector c(1, 3).

...\

  |=================================================================          |  87%

| Use the which() function to find the indices of ints that are greater than 7.

> which(ints > 7)
[1] 4 8 9

| You are doing so well!

  |==================================================================         |  88%

| Which of the following commands would produce the indices of the elements in ints
| that are less than or equal to 2?

1: ints < 2
2: ints <= 2
3: which(ints < 2)
4: which(ints <= 2)

Selection: 4

| You got it right!

  |====================================================================       |  90%

| Like the which() function, the functions any() and all() take logical vectors as
| their argument. The any() function will return TRUE if one or more of the elements
| in the logical vector is TRUE. The all() function will return TRUE if every
| element in the logical vector is TRUE.

...

  |=====================================================================      |  92%

| Use the any() function to see if any of the elements of ints are less than zero.

> any(ints < 0)
[1] FALSE

| All that practice is paying off!

  |=======================================================================    |  94%

| Use the all() function to see if all of the elements of ints are greater than
| zero.

> all(ints > 0)
[1] TRUE

| You are doing so well!

  |========================================================================   |  96%

| Which of the following evaluates to TRUE?

1: all(ints == 10)
2: all(c(TRUE, FALSE, TRUE))
3: any(ints == 2.5)
4: any(ints == 10)

Selection: 4

| Excellent work!

  |========================================================================== |  98%

| That's all for this introduction to logic in R. If you really want to see what you
| can do with logic, check out the control flow lesson!

...

  |===========================================================================| 100%

| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 1

| Great job!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files     
 3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times         
15: Base Graphics             

Selection: 9

  |                                                                           |   0%

| Functions are one of the fundamental building blocks of the R language. They are
| small pieces of reusable code that can be treated like any other R object.

...

  |==                                                                         |   2%

| If you've worked through any other part of this course, you've probably used some
| functions already. Functions are usually characterized by the name of the function
| followed by parentheses.

...

  |===                                                                        |   4%

| Let's try using a few basic functions just for fun. The Sys.Date() function
| returns a string representing today's date. Type Sys.Date() below and see what
| happens.

> Sys.Date()
[1] "2017-09-09"

| You got it!

  |=====                                                                      |   6%

| Most functions in R return a value. Functions like Sys.Date() return a value based
| on your computer's environment, while other functions manipulate input data in
| order to compute a return value.

...

  |======                                                                     |   8%

| The mean() function takes a vector of numbers as input, and returns the average of
| all of the numbers in the input vector. Inputs to functions are often called
| arguments. Providing arguments to a function is also sometimes called passing
| arguments to that function. Arguments you want to pass to a function go inside the
| function's parentheses. Try passing the argument c(2, 4, 5) to the mean()
| function.

> mean(c(2, 4, 5))
[1] 3.666667

| Nice work!

  |========                                                                   |  10%

| Functions usually take arguments which are variables that the function operates
| on. For example, the mean() function takes a vector as an argument, like in the
| case of mean(c(2,6,8)). The mean() function then adds up all of the numbers in the
| vector and divides that sum by the length of the vector.

...

  |=========                                                                  |  12%

| In the following question you will be asked to modify a script that will appear as
| soon as you move on from this question. When you have finished modifying the
| script, save your changes to the script and type submit() and the script will be
| evaluated. There will be some comments in the script that opens up, so be sure to
| read them!

...

  |===========                                                                |  14%

| The last R expression to be evaluated in a function will become the return value
| of that function. We want this function to take one argument, x, and return x
| without modifying it. Delete the pound sign so that x is returned without any
| modification. Make sure to save your script before you type submit().

> 
> submit()

| Sourcing your script...


| Almost! Try again.

| Make sure to delete the pound sign so the last expression in the function is just
| x.

> submit()

| Sourcing your script...


| Excellent work!

  |============                                                               |  16%

| Now that you've created your first function let's test it! Type:
| boring_function('My first function!'). If your function works, it should just
| return the string: 'My first function!'

> boring_function('My first function!')
[1] "My first function!"

| You are doing so well!

  |==============                                                             |  18%

| Congratulations on writing your first function. By writing functions, you can gain
| serious insight into how R works. As John Chambers, the creator of R once said:
| 
| To understand computations in R, two slogans are helpful: 1. Everything that
| exists is an object. 2. Everything that happens is a function call.

...

  |===============                                                            |  20%

| If you want to see the source code for any function, just type the function name
| without any arguments or parentheses. Let's try this out with the function you
| just created. Type: boring_function to view its source code.

> boring_function()
Error in boring_function() : argument "x" is missing, with no default
> boring_function
function(x) {
  x
}
<bytecode: 0x000000001c288b08>

| That's correct!

  |=================                                                          |  22%

| Time to make a more useful function! We're going to replicate the functionality of
| the mean() function by creating a function called: my_mean(). Remember that to
| calculate the average of all of the numbers in a vector you find the sum of all
| the numbers in the vector, and then divide that sum by the number of numbers in
| the vector.

...

  |==================                                                         |  24%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Keep working like that and you'll get there!

  |====================                                                       |  27%

| Now test out your my_mean() function by finding the mean of the vector c(4, 5,
| 10).

> my_mean(c(4, 5, 10))
[1] 6.333333

| Keep working like that and you'll get there!

  |=====================                                                      |  29%

| Next, let's try writing a function with default arguments. You can set default
| values for a function's arguments, and this can be useful if you think someone who
| uses your function will set a certain argument to the same value most of the time.

...

  |=======================                                                    |  31%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  C:\Users\Steven\AppData\Local\Temp\RtmpMFgAdT/remainder.R:36:7: unexpected input
35:   # Remember: the last expression evaluated will be returned! 
36:   num % divisor
          ^

| Not exactly. Give it another go.

| Remember to set the appropriate default values!

> submit()

| Sourcing your script...


| Try again. Getting it right on the first try is boring anyway!

| Remember to set the appropriate default values!

> submit()

| Sourcing your script...


| You are doing so well!

  |========================                                                   |  33%

| Let's do some testing of the remainder function. Run remainder(5) and see what
| happens.

> remainder(5)
[1] 1

| Keep up the great work!

  |==========================                                                 |  35%

| Let's take a moment to examine what just happened. You provided one argument to
| the function, and R matched that argument to 'num' since 'num' is the first
| argument. The default value for 'divisor' is 2, so the function used the default
| value you provided.

...

  |============================                                               |  37%

| Now let's test the remainder function by providing two arguments. Type:
| remainder(11, 5) and let's see what happens.

> remainder(11, 5)
[1] 1

| Excellent job!

  |=============================                                              |  39%

| Once again, the arguments have been matched appropriately.

...

  |===============================                                            |  41%

| You can also explicitly specify arguments in a function. When you explicitly
| designate argument values by name, the ordering of the arguments becomes
| unimportant. You can try this out by typing: remainder(divisor = 11, num = 5).

> remainder(divisor = 11, num = 5)
[1] 5

| You are amazing!

  |================================                                           |  43%

| As you can see, there is a significant difference between remainder(11, 5) and
| remainder(divisor = 11, num = 5)!

...

  |==================================                                         |  45%

| R can also partially match arguments. Try typing remainder(4, div = 2) to see this
| feature in action.

> remainder(4, div = 2)
[1] 0

| You are quite good my friend!

  |===================================                                        |  47%

| A word of warning: in general you want to make your code as easy to understand as
| possible. Switching around the orders of arguments by specifying their names or
| only using partial argument names can be confusing, so use these features with
| caution!

...

  |=====================================                                      |  49%

| With all of this talk about arguments, you may be wondering if there is a way you
| can see a function's arguments (besides looking at the documentation). Thankfully,
| you can use the args() function! Type: args(remainder) to examine the arguments
| for the remainder function.

> args(remainder)
function (num, divisor = 2) 
NULL

| You got it right!

  |======================================                                     |  51%

| You may not realize it but I just tricked you into doing something pretty
| interesting! args() is a function, remainder() is a function, yet remainder was an
| argument for args(). Yes it's true: you can pass functions as arguments! This is a
| very powerful concept. Let's write a script to see how it works.

...

  |========================================                                   |  53%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| You're the best!

  |=========================================                                  |  55%

| Let's take your new evaluate() function for a spin! Use evaluate to find the
| standard deviation of the vector c(1.4, 3.6, 7.9, 8.8).

> evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
[1] 3.514138

| You are really on a roll!

  |===========================================                                |  57%

| The idea of passing functions as arguments to other functions is an important and
| fundamental concept in programming.

...

  |============================================                               |  59%

| You may be surprised to learn that you can pass a function as an argument without
| first defining the passed function. Functions that are not named are appropriately
| known as anonymous functions.

...

  |==============================================                             |  61%

| Let's use the evaluate function to explore how anonymous functions work. For the
| first argument of the evaluate function we're going to write a tiny function that
| fits on one line. In the second argument we'll pass some data to the tiny
| anonymous function in the first argument.

...

  |===============================================                            |  63%

| Type the following command and then we'll discuss how it works:
| evaluate(function(x){x+1}, 6)

> evaluate(function(x){x+1}, 6)
[1] 7

| You are doing so well!

  |=================================================                          |  65%

| The first argument is a tiny anonymous function that takes one argument `x` and
| returns `x+1`. We passed the number 6 into this function so the entire expression
| evaluates to 7.

...

  |===================================================                        |  67%

| Try using evaluate() along with an anonymous function to return the first element
| of the vector c(8, 4, 0). Your anonymous function should only take one argument
| which should be a variable `x`.

> evaluate(function(x){x[1]}, c(8, 4, 0))
[1] 8

| You got it right!

  |====================================================                       |  69%

| Now try using evaluate() along with an anonymous function to return the last
| element of the vector c(8, 4, 0). Your anonymous function should only take one
| argument which should be a variable `x`.

> evaluate(function(x){x[length(x)]}, c(8, 4, 0))
[1] 0

| You are quite good my friend!

  |======================================================                     |  71%

| For the rest of the course we're going to use the paste() function frequently.
| Type ?paste so we can take a look at the documentation for the paste function.

> ?paste

| That's correct!

  |=======================================================                    |  73%

| As you can see the first argument of paste() is `...` which is referred to as an
| ellipsis or simply dot-dot-dot. The ellipsis allows an indefinite number of
| arguments to be passed into a function. In the case of paste() any number of
| strings can be passed as arguments and paste() will return all of the strings
| combined into one string.

...

  |=========================================================                  |  76%

| Just to see how paste() works, type paste("Programming", "is", "fun!")

> paste("Programming", "is", "fun!")
[1] "Programming is fun!"

| You are amazing!

  |==========================================================                 |  78%

| Time to write our own modified version of paste().

...

  |============================================================               |  80%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Keep up the great work!

  |=============================================================              |  82%

| Now let's test out your telegram function. Use your new telegram function passing
| in whatever arguments you wish!

> paste("STOP","START")
[1] "STOP START"

| You're close...I can feel it! Try it again. Or, type info() for more options.

| Use the telegram function with whatever arguments you want to use.

> telegram("STOP","START")
[1] "START STOP START STOP"

| All that hard work is paying off!

  |===============================================================            |  84%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Keep up the great work!

  |================================================================           |  86%

| Time to use your mad_libs function. Make sure to name the place, adjective, and
| noun arguments in order for your function to work.

> mad_libs("New York", "purple", "helicopter")
[1] "News from NULL today where NULL students took to the streets in protest of the new NULL being installed on campus."

| You are amazing!

  |==================================================================         |  88%

| We're coming to the end of this lesson, but there's still one more idea you should
| be made aware of.

...

  |===================================================================        |  90%

| You're familiar with adding, subtracting, multiplying, and dividing numbers in R.
| To do this you use the +, -, *, and / symbols. These symbols are called binary
| operators because they take two inputs, an input from the left and an input from
| the right.

...

  |=====================================================================      |  92%

| In R you can define your own binary operators. In the next script I'll show you
| how.

...

  |======================================================================     |  94%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| That's correct!

  |========================================================================   |  96%

| You made your own binary operator! Let's test it out. Paste together the strings:
| 'I', 'love', 'R!' using your new binary operator.

> 'I'%p%'love'%p%'R!'
[1] "I love R!"

| You are doing so well!

  |=========================================================================  |  98%

| We've come to the end of our lesson! Go out there and write some great functions!

...

  |===========================================================================| 100%

| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 1

| You got it right!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files     
 3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times         
15: Base Graphics             

Selection: 10

   |                                                                           |   0%

| In this lesson, you'll learn how to use lapply() and sapply(), the two most
| important members of R's *apply family of functions, also known as loop functions.

...

  |==                                                                         |   2%

| These powerful functions, along with their close relatives (vapply() and tapply(),
| among others) offer a concise and convenient means of implementing the
| Split-Apply-Combine strategy for data analysis.

...

  |===                                                                        |   4%

| Each of the *apply functions will SPLIT up some data into smaller pieces, APPLY a
| function to each piece, then COMBINE the results. A more detailed discussion of
| this strategy is found in Hadley Wickham's Journal of Statistical Software paper
| titled 'The Split-Apply-Combine Strategy for Data Analysis'.

...

  |====                                                                       |   6%

| Throughout this lesson, we'll use the Flags dataset from the UCI Machine Learning
| Repository. This dataset contains details of various nations and their flags. More
| information may be found here: http://archive.ics.uci.edu/ml/datasets/Flags

...

  |======                                                                     |   8%

| Let's jump right in so you can get a feel for how these special functions work!

...

  |========                                                                   |  10%

| I've stored the dataset in a variable called flags. Type head(flags) to preview
| the first six lines (i.e. the 'head') of the dataset.

> 
> head(flags)
            name landmass zone area population language religion bars stripes
1    Afghanistan        5    1  648         16       10        2    0       3
2        Albania        3    1   29          3        6        6    0       0
3        Algeria        4    1 2388         20        8        2    2       0
4 American-Samoa        6    3    0          0        1        1    0       0
5        Andorra        3    1    0          0        6        0    3       0
6         Angola        4    2 1247          7       10        5    0       2
  colours red green blue gold white black orange mainhue circles crosses saltires
1       5   1     1    0    1     1     1      0   green       0       0        0
2       3   1     0    0    1     0     1      0     red       0       0        0
3       3   1     1    0    0     1     0      0   green       0       0        0
4       5   1     0    1    1     1     0      1    blue       0       0        0
5       3   1     0    1    1     0     0      0    gold       0       0        0
6       3   1     0    0    1     0     1      0     red       0       0        0
  quarters sunstars crescent triangle icon animate text topleft botright
1        0        1        0        0    1       0    0   black    green
2        0        1        0        0    0       1    0     red      red
3        0        1        1        0    0       0    0   green    white
4        0        0        0        1    1       1    0    blue      red
5        0        0        0        0    0       0    0    blue      red
6        0        1        0        0    1       0    0     red    black

| You're the best!

  |=========                                                                  |  12%

| You may need to scroll up to see all of the output. Now, let's check out the
| dimensions of the dataset using dim(flags).

> dim(flags)
[1] 194  30

| You nailed it! Good job!

  |===========                                                                |  14%

| This tells us that there are 194 rows, or observations, and 30 columns, or
| variables. Each observation is a country and each variable describes some
| characteristic of that country or its flag. To open a more complete description of
| the dataset in a separate text file, type viewinfo() when you are back at the
| prompt (>).

...

  |============                                                               |  16%

| As with any dataset, we'd like to know in what format the variables have been
| stored. In other words, what is the 'class' of each variable? What happens if we
| do class(flags)? Try it out.

> class(flags)
[1] "data.frame"

| That's the answer I was looking for.

  |==============                                                             |  18%

| That just tells us that the entire dataset is stored as a 'data.frame', which
| doesn't answer our question. What we really need is to call the class() function
| on each individual column. While we could do this manually (i.e. one column at a
| time) it's much faster if we can automate the process. Sounds like a loop!

...

  |===============                                                            |  20%

| The lapply() function takes a list as input, applies a function to each element of
| the list, then returns a list of the same length as the original one. Since a data
| frame is really just a list of vectors (you can see this with as.list(flags)), we
| can use lapply() to apply the class() function to each column of the flags
| dataset. Let's see it in action!

...

  |================                                                           |  22%

| Type cls_list <- lapply(flags, class) to apply the class() function to each column
| of the flags dataset and store the result in a variable called cls_list. Note that
| you just supply the name of the function you want to apply (i.e. class), without
| the usual parentheses after it.

> cls_list <- lapply(flags, class)

| You nailed it! Good job!

  |==================                                                         |  24%

| Type cls_list to view the result.

> cls_list
$name
[1] "factor"

$landmass
[1] "integer"

$zone
[1] "integer"

$area
[1] "integer"

$population
[1] "integer"

$language
[1] "integer"

$religion
[1] "integer"

$bars
[1] "integer"

$stripes
[1] "integer"

$colours
[1] "integer"

$red
[1] "integer"

$green
[1] "integer"

$blue
[1] "integer"

$gold
[1] "integer"

$white
[1] "integer"

$black
[1] "integer"

$orange
[1] "integer"

$mainhue
[1] "factor"

$circles
[1] "integer"

$crosses
[1] "integer"

$saltires
[1] "integer"

$quarters
[1] "integer"

$sunstars
[1] "integer"

$crescent
[1] "integer"

$triangle
[1] "integer"

$icon
[1] "integer"

$animate
[1] "integer"

$text
[1] "integer"

$topleft
[1] "factor"

$botright
[1] "factor"


| Excellent job!

  |====================                                                       |  26%

| The 'l' in 'lapply' stands for 'list'. Type class(cls_list) to confirm that
| lapply() returned a list.

> class(cls_list)
[1] "list"

| You are amazing!

  |=====================                                                      |  28%

| As expected, we got a list of length 30 -- one element for each variable/column.
| The output would be considerably more compact if we could represent it as a vector
| instead of a list.

...

  |======================                                                     |  30%

| You may remember from a previous lesson that lists are most helpful for storing
| multiple classes of data. In this case, since every element of the list returned
| by lapply() is a character vector of length one (i.e. "integer" and "vector"),
| cls_list can be simplified to a character vector. To do this manually, type
| as.character(cls_list).

> as.character(cls_list)
 [1] "factor"  "integer" "integer" "integer" "integer" "integer" "integer" "integer"
 [9] "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer"
[17] "integer" "factor"  "integer" "integer" "integer" "integer" "integer" "integer"
[25] "integer" "integer" "integer" "integer" "factor"  "factor" 

| That's the answer I was looking for.

  |========================                                                   |  32%

| sapply() allows you to automate this process by calling lapply() behind the
| scenes, but then attempting to simplify (hence the 's' in 'sapply') the result for
| you. Use sapply() the same way you used lapply() to get the class of each column
| of the flags dataset and store the result in cls_vect. If you need help, type
| ?sapply to bring up the documentation.

> 
> ?sapply
> cls_vect <- sapply(flags, class)

| Excellent work!

  |==========================                                                 |  34%

| Use class(cls_vect) to confirm that sapply() simplified the result to a character
| vector.

> class(cls_vect)
[1] "character"

| You are quite good my friend!

  |===========================                                                |  36%

| In general, if the result is a list where every element is of length one, then
| sapply() returns a vector. If the result is a list where every element is a vector
| of the same length (> 1), sapply() returns a matrix. If sapply() can't figure
| things out, then it just returns a list, no different from what lapply() would
| give you.

...

  |============================                                               |  38%

| Let's practice using lapply() and sapply() some more!

...

  |==============================                                             |  40%

| Columns 11 through 17 of our dataset are indicator variables, each representing a
| different color. The value of the indicator variable is 1 if the color is present
| in a country's flag and 0 otherwise.

...

  |================================                                           |  42%

| Therefore, if we want to know the total number of countries (in our dataset) with,
| for example, the color orange on their flag, we can just add up all of the 1s and
| 0s in the 'orange' column. Try sum(flags$orange) to see this.

> sum(flags$orange)
[1] 26

| You got it right!

  |=================================                                          |  44%

| Now we want to repeat this operation for each of the colors recorded in the
| dataset.

...

  |==================================                                         |  46%

| First, use flag_colors <- flags[, 11:17] to extract the columns containing the
| color data and store them in a new data frame called flag_colors. (Note the comma
| before 11:17. This subsetting command tells R that we want all rows, but only
| columns 11 through 17.)

> flag_colors <- flags[, 11:17]

| Excellent work!

  |====================================                                       |  48%

| Use the head() function to look at the first 6 lines of flag_colors.

> head(flag_colors)
  red green blue gold white black orange
1   1     1    0    1     1     1      0
2   1     0    0    1     0     1      0
3   1     1    0    0     1     0      0
4   1     0    1    1     1     0      1
5   1     0    1    1     0     0      0
6   1     0    0    1     0     1      0

| You are amazing!

  |======================================                                     |  50%

| To get a list containing the sum of each column of flag_colors, call the lapply()
| function with two arguments. The first argument is the object over which we are
| looping (i.e. flag_colors) and the second argument is the name of the function we
| wish to apply to each column (i.e. sum). Remember that the second argument is just
| the name of the function with no parentheses, etc.

> lapply(flag_colors, sum)
$red
[1] 153

$green
[1] 91

$blue
[1] 99

$gold
[1] 91

$white
[1] 146

$black
[1] 52

$orange
[1] 26


| Your dedication is inspiring!

  |=======================================                                    |  52%

| This tells us that of the 194 flags in our dataset, 153 contain the color red, 91
| contain green, 99 contain blue, and so on.

...

  |========================================                                   |  54%

| The result is a list, since lapply() always returns a list. Each element of this
| list is of length one, so the result can be simplified to a vector by calling
| sapply() instead of lapply(). Try it now.

> 
> sapply(flag_colors,sum)
   red  green   blue   gold  white  black orange 
   153     91     99     91    146     52     26 

| That's a job well done!

  |==========================================                                 |  56%

| Perhaps it's more informative to find the proportion of flags (out of 194)
| containing each color. Since each column is just a bunch of 1s and 0s, the
| arithmetic mean of each column will give us the proportion of 1s. (If it's not
| clear why, think of a simpler situation where you have three 1s and two 0s -- (1 +
| 1 + 1 + 0 + 0)/5 = 3/5 = 0.6).

...

  |============================================                               |  58%

| Use sapply() to apply the mean() function to each column of flag_colors. Remember
| that the second argument to sapply() should just specify the name of the function
| (i.e. mean) that you want to apply.

> sapply(flag_colors, mean)
      red     green      blue      gold     white     black    orange 
0.7886598 0.4690722 0.5103093 0.4690722 0.7525773 0.2680412 0.1340206 

| Excellent job!

  |=============================================                              |  60%

| In the examples we've looked at so far, sapply() has been able to simplify the
| result to vector. That's because each element of the list returned by lapply() was
| a vector of length one. Recall that sapply() instead returns a matrix when each
| element of the list returned by lapply() is a vector of the same length (> 1).

...

  |==============================================                             |  62%

| To illustrate this, let's extract columns 19 through 23 from the flags dataset and
| store the result in a new data frame called flag_shapes. flag_shapes <- flags[,
| 19:23] will do it.

> flag_shapes <- flags[, 19:23]

| Nice work!

  |================================================                           |  64%

| Each of these columns (i.e. variables) represents the number of times a particular
| shape or design appears on a country's flag. We are interested in the minimum and
| maximum number of times each shape or design appears.

...

  |==================================================                         |  66%

| The range() function returns the minimum and maximum of its first argument, which
| should be a numeric vector. Use lapply() to apply the range function to each
| column of flag_shapes. Don't worry about storing the result in a new variable. By
| now, we know that lapply() always returns a list.

> lapply(flag_shapes, range)
$circles
[1] 0 4

$crosses
[1] 0 2

$saltires
[1] 0 1

$quarters
[1] 0 4

$sunstars
[1]  0 50


| Keep up the great work!

  |===================================================                        |  68%

| Do the same operation, but using sapply() and store the result in a variable
| called shape_mat.

> shape_mat <- sapply(flag_shapes, range)

| All that hard work is paying off!

  |=====================================================                      |  70%

| View the contents of shape_mat.

> shape_mat
     circles crosses saltires quarters sunstars
[1,]       0       0        0        0        0
[2,]       4       2        1        4       50

| You are quite good my friend!

  |======================================================                     |  72%

| Each column of shape_mat gives the minimum (row 1) and maximum (row 2) number of
| times its respective shape appears in different flags.

...

  |========================================================                   |  74%

| Use the class() function to confirm that shape_mat is a matrix.

> class(shape_mat)
[1] "matrix"

| You are quite good my friend!

  |=========================================================                  |  76%

| As we've seen, sapply() always attempts to simplify the result given by lapply().
| It has been successful in doing so for each of the examples we've looked at so
| far. Let's look at an example where sapply() can't figure out how to simplify the
| result and thus returns a list, no different from lapply().

...

  |==========================================================                 |  78%

| When given a vector, the unique() function returns a vector with all duplicate
| elements removed. In other words, unique() returns a vector of only the 'unique'
| elements. To see how it works, try unique(c(3, 4, 5, 5, 5, 6, 6)).

> unique(c(3, 4, 5, 5, 5, 6, 6))
[1] 3 4 5 6

| You got it!

  |============================================================               |  80%

| We want to know the unique values for each variable in the flags dataset. To
| accomplish this, use lapply() to apply the unique() function to each column in the
| flags dataset, storing the result in a variable called unique_vals.

> unique_vals <- lapply(unique, flags)
Error in get(as.character(FUN), mode = "function", envir = envir) : 
  object 'flags' of mode 'function' was not found
> unique_vals <- lapply(flags, unique)

| Great job!

  |==============================================================             |  82%

| Print the value of unique_vals to the console.

> unique_vals
$name
  [1] Afghanistan              Albania                  Algeria                 
  [4] American-Samoa           Andorra                  Angola                  
  [7] Anguilla                 Antigua-Barbuda          Argentina               
 [10] Argentine                Australia                Austria                 
 [13] Bahamas                  Bahrain                  Bangladesh              
 [16] Barbados                 Belgium                  Belize                  
 [19] Benin                    Bermuda                  Bhutan                  
 [22] Bolivia                  Botswana                 Brazil                  
 [25] British-Virgin-Isles     Brunei                   Bulgaria                
 [28] Burkina                  Burma                    Burundi                 
 [31] Cameroon                 Canada                   Cape-Verde-Islands      
 [34] Cayman-Islands           Central-African-Republic Chad                    
 [37] Chile                    China                    Colombia                
 [40] Comorro-Islands          Congo                    Cook-Islands            
 [43] Costa-Rica               Cuba                     Cyprus                  
 [46] Czechoslovakia           Denmark                  Djibouti                
 [49] Dominica                 Dominican-Republic       Ecuador                 
 [52] Egypt                    El-Salvador              Equatorial-Guinea       
 [55] Ethiopia                 Faeroes                  Falklands-Malvinas      
 [58] Fiji                     Finland                  France                  
 [61] French-Guiana            French-Polynesia         Gabon                   
 [64] Gambia                   Germany-DDR              Germany-FRG             
 [67] Ghana                    Gibraltar                Greece                  
 [70] Greenland                Grenada                  Guam                    
 [73] Guatemala                Guinea                   Guinea-Bissau           
 [76] Guyana                   Haiti                    Honduras                
 [79] Hong-Kong                Hungary                  Iceland                 
 [82] India                    Indonesia                Iran                    
 [85] Iraq                     Ireland                  Israel                  
 [88] Italy                    Ivory-Coast              Jamaica                 
 [91] Japan                    Jordan                   Kampuchea               
 [94] Kenya                    Kiribati                 Kuwait                  
 [97] Laos                     Lebanon                  Lesotho                 
[100] Liberia                  Libya                    Liechtenstein           
[103] Luxembourg               Malagasy                 Malawi                  
[106] Malaysia                 Maldive-Islands          Mali                    
[109] Malta                    Marianas                 Mauritania              
[112] Mauritius                Mexico                   Micronesia              
[115] Monaco                   Mongolia                 Montserrat              
[118] Morocco                  Mozambique               Nauru                   
[121] Nepal                    Netherlands              Netherlands-Antilles    
[124] New-Zealand              Nicaragua                Niger                   
[127] Nigeria                  Niue                     North-Korea             
[130] North-Yemen              Norway                   Oman                    
[133] Pakistan                 Panama                   Papua-New-Guinea        
[136] Parguay                  Peru                     Philippines             
[139] Poland                   Portugal                 Puerto-Rico             
[142] Qatar                    Romania                  Rwanda                  
[145] San-Marino               Sao-Tome                 Saudi-Arabia            
[148] Senegal                  Seychelles               Sierra-Leone            
[151] Singapore                Soloman-Islands          Somalia                 
[154] South-Africa             South-Korea              South-Yemen             
[157] Spain                    Sri-Lanka                St-Helena               
[160] St-Kitts-Nevis           St-Lucia                 St-Vincent              
[163] Sudan                    Surinam                  Swaziland               
[166] Sweden                   Switzerland              Syria                   
[169] Taiwan                   Tanzania                 Thailand                
[172] Togo                     Tonga                    Trinidad-Tobago         
[175] Tunisia                  Turkey                   Turks-Cocos-Islands     
[178] Tuvalu                   UAE                      Uganda                  
[181] UK                       Uruguay                  US-Virgin-Isles         
[184] USA                      USSR                     Vanuatu                 
[187] Vatican-City             Venezuela                Vietnam                 
[190] Western-Samoa            Yugoslavia               Zaire                   
[193] Zambia                   Zimbabwe                
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola ... Zimbabwe

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31    23
 [14]   113    47  1099   600  8512     6   111   274   678    28   474  9976     4
 [27]   623  1284   757  9561  1139     2   342    51   115     9   128    43    22
 [40]    49   284  1001    21  1222    12    18   337   547    91   268    10   108
 [53]   249   239   132  2176   109   246    36   215   112    93   103  3268  1904
 [66]  1648   435    70   301   323    11   372    98   181   583   236    30  1760
 [79]     3   587   118   333  1240  1031  1973  1566   447   783   140    41  1267
 [92]   925   121   195   324   212   804    76   463   407  1285   300   313    92
[105]   237    26  2150   196    72   637  1221    99   288   505    66  2506    63
[118]    17   450   185   945   514    57     5   164   781   245   178  9363 22402
[131]    15   912   256   905   753   391

$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9   35    4
[17]   24    2   11 1008    5   47   31   54   17   61   14  684  157   39   57  118
[33]   13   77   12   56   18   84   48   36   22   29   38   49   45  231  274   60

$language
 [1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] green  red    blue   gold   white  orange black  brown 
Levels: black blue brown gold green orange red white

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] black  red    green  blue   white  orange gold  
Levels: black blue gold green orange red white

$botright
[1] green  red    white  black  blue   gold   orange brown 
Levels: black blue brown gold green orange red white


| You're the best!

  |===============================================================            |  84%

| Since unique_vals is a list, you can use what you've learned to determine the
| length of each element of unique_vals (i.e. the number of unique values for each
| variable). Simplify the result, if possible. Hint: Apply the length() function to
| each element of unique_vals.

> lapply(unique_vals, length)
$name
[1] 194

$landmass
[1] 6

$zone
[1] 4

$area
[1] 136

$population
[1] 48

$language
[1] 10

$religion
[1] 8

$bars
[1] 5

$stripes
[1] 12

$colours
[1] 8

$red
[1] 2

$green
[1] 2

$blue
[1] 2

$gold
[1] 2

$white
[1] 2

$black
[1] 2

$orange
[1] 2

$mainhue
[1] 8

$circles
[1] 4

$crosses
[1] 3

$saltires
[1] 2

$quarters
[1] 3

$sunstars
[1] 14

$crescent
[1] 2

$triangle
[1] 2

$icon
[1] 2

$animate
[1] 2

$text
[1] 2

$topleft
[1] 7

$botright
[1] 8


| Give it another try. Or, type info() for more options.

| Apply the length() function to each element of the unique_vals list using
| sapply(). Remember, no parentheses after the name of the function you are applying
| (i.e. length).

> sapply(unique_vals, length)
      name   landmass       zone       area population   language   religion 
       194          6          4        136         48         10          8 
      bars    stripes    colours        red      green       blue       gold 
         5         12          8          2          2          2          2 
     white      black     orange    mainhue    circles    crosses   saltires 
         2          2          2          8          4          3          2 
  quarters   sunstars   crescent   triangle       icon    animate       text 
         3         14          2          2          2          2          2 
   topleft   botright 
         7          8 

| You are amazing!

  |================================================================           |  86%

| The fact that the elements of the unique_vals list are all vectors of *different*
| length poses a problem for sapply(), since there's no obvious way of simplifying
| the result.

...

  |==================================================================         |  88%

| Use sapply() to apply the unique() function to each column of the flags dataset to
| see that you get the same unsimplified list that you got from lapply().

> sapply(flags, unique)
$name
  [1] Afghanistan              Albania                  Algeria                 
  [4] American-Samoa           Andorra                  Angola                  
  [7] Anguilla                 Antigua-Barbuda          Argentina               
 [10] Argentine                Australia                Austria                 
 [13] Bahamas                  Bahrain                  Bangladesh              
 [16] Barbados                 Belgium                  Belize                  
 [19] Benin                    Bermuda                  Bhutan                  
 [22] Bolivia                  Botswana                 Brazil                  
 [25] British-Virgin-Isles     Brunei                   Bulgaria                
 [28] Burkina                  Burma                    Burundi                 
 [31] Cameroon                 Canada                   Cape-Verde-Islands      
 [34] Cayman-Islands           Central-African-Republic Chad                    
 [37] Chile                    China                    Colombia                
 [40] Comorro-Islands          Congo                    Cook-Islands            
 [43] Costa-Rica               Cuba                     Cyprus                  
 [46] Czechoslovakia           Denmark                  Djibouti                
 [49] Dominica                 Dominican-Republic       Ecuador                 
 [52] Egypt                    El-Salvador              Equatorial-Guinea       
 [55] Ethiopia                 Faeroes                  Falklands-Malvinas      
 [58] Fiji                     Finland                  France                  
 [61] French-Guiana            French-Polynesia         Gabon                   
 [64] Gambia                   Germany-DDR              Germany-FRG             
 [67] Ghana                    Gibraltar                Greece                  
 [70] Greenland                Grenada                  Guam                    
 [73] Guatemala                Guinea                   Guinea-Bissau           
 [76] Guyana                   Haiti                    Honduras                
 [79] Hong-Kong                Hungary                  Iceland                 
 [82] India                    Indonesia                Iran                    
 [85] Iraq                     Ireland                  Israel                  
 [88] Italy                    Ivory-Coast              Jamaica                 
 [91] Japan                    Jordan                   Kampuchea               
 [94] Kenya                    Kiribati                 Kuwait                  
 [97] Laos                     Lebanon                  Lesotho                 
[100] Liberia                  Libya                    Liechtenstein           
[103] Luxembourg               Malagasy                 Malawi                  
[106] Malaysia                 Maldive-Islands          Mali                    
[109] Malta                    Marianas                 Mauritania              
[112] Mauritius                Mexico                   Micronesia              
[115] Monaco                   Mongolia                 Montserrat              
[118] Morocco                  Mozambique               Nauru                   
[121] Nepal                    Netherlands              Netherlands-Antilles    
[124] New-Zealand              Nicaragua                Niger                   
[127] Nigeria                  Niue                     North-Korea             
[130] North-Yemen              Norway                   Oman                    
[133] Pakistan                 Panama                   Papua-New-Guinea        
[136] Parguay                  Peru                     Philippines             
[139] Poland                   Portugal                 Puerto-Rico             
[142] Qatar                    Romania                  Rwanda                  
[145] San-Marino               Sao-Tome                 Saudi-Arabia            
[148] Senegal                  Seychelles               Sierra-Leone            
[151] Singapore                Soloman-Islands          Somalia                 
[154] South-Africa             South-Korea              South-Yemen             
[157] Spain                    Sri-Lanka                St-Helena               
[160] St-Kitts-Nevis           St-Lucia                 St-Vincent              
[163] Sudan                    Surinam                  Swaziland               
[166] Sweden                   Switzerland              Syria                   
[169] Taiwan                   Tanzania                 Thailand                
[172] Togo                     Tonga                    Trinidad-Tobago         
[175] Tunisia                  Turkey                   Turks-Cocos-Islands     
[178] Tuvalu                   UAE                      Uganda                  
[181] UK                       Uruguay                  US-Virgin-Isles         
[184] USA                      USSR                     Vanuatu                 
[187] Vatican-City             Venezuela                Vietnam                 
[190] Western-Samoa            Yugoslavia               Zaire                   
[193] Zambia                   Zimbabwe                
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola ... Zimbabwe

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31    23
 [14]   113    47  1099   600  8512     6   111   274   678    28   474  9976     4
 [27]   623  1284   757  9561  1139     2   342    51   115     9   128    43    22
 [40]    49   284  1001    21  1222    12    18   337   547    91   268    10   108
 [53]   249   239   132  2176   109   246    36   215   112    93   103  3268  1904
 [66]  1648   435    70   301   323    11   372    98   181   583   236    30  1760
 [79]     3   587   118   333  1240  1031  1973  1566   447   783   140    41  1267
 [92]   925   121   195   324   212   804    76   463   407  1285   300   313    92
[105]   237    26  2150   196    72   637  1221    99   288   505    66  2506    63
[118]    17   450   185   945   514    57     5   164   781   245   178  9363 22402
[131]    15   912   256   905   753   391

$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9   35    4
[17]   24    2   11 1008    5   47   31   54   17   61   14  684  157   39   57  118
[33]   13   77   12   56   18   84   48   36   22   29   38   49   45  231  274   60

$language
 [1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] green  red    blue   gold   white  orange black  brown 
Levels: black blue brown gold green orange red white

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] black  red    green  blue   white  orange gold  
Levels: black blue gold green orange red white

$botright
[1] green  red    white  black  blue   gold   orange brown 
Levels: black blue brown gold green orange red white


| You got it!

  |====================================================================       |  90%

| Occasionally, you may need to apply a function that is not yet defined, thus
| requiring you to write your own. Writing functions in R is beyond the scope of
| this lesson, but let's look at a quick example of how you might do so in the
| context of loop functions.

...

  |=====================================================================      |  92%

| Pretend you are interested in only the second item from each element of the
| unique_vals list that you just created. Since each element of the unique_vals list
| is a vector and we're not aware of any built-in function in R that returns the
| second element of a vector, we will construct our own function.

...

  |======================================================================     |  94%

| lapply(unique_vals, function(elem) elem[2]) will return a list containing the
| second item from each element of the unique_vals list. Note that our function
| takes one argument, elem, which is just a 'dummy variable' that takes on the value
| of each element of unique_vals, in turn.

> lapply(unique_vals, function(elem elem[2])
Error: unexpected symbol in "lapply(unique_vals, function(elem elem"
> lapply(unique_vals, function(elem) elem[2])
$name
[1] Albania
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola ... Zimbabwe

$landmass
[1] 3

$zone
[1] 3

$area
[1] 29

$population
[1] 3

$language
[1] 6

$religion
[1] 6

$bars
[1] 2

$stripes
[1] 0

$colours
[1] 3

$red
[1] 0

$green
[1] 0

$blue
[1] 1

$gold
[1] 0

$white
[1] 0

$black
[1] 0

$orange
[1] 1

$mainhue
[1] red
Levels: black blue brown gold green orange red white

$circles
[1] 1

$crosses
[1] 1

$saltires
[1] 1

$quarters
[1] 1

$sunstars
[1] 0

$crescent
[1] 1

$triangle
[1] 1

$icon
[1] 0

$animate
[1] 1

$text
[1] 1

$topleft
[1] red
Levels: black blue gold green orange red white

$botright
[1] red
Levels: black blue brown gold green orange red white


| Perseverance, that's the answer.

  |========================================================================   |  96%

| The only difference between previous examples and this one is that we are defining
| and using our own function right in the call to lapply(). Our function has no name
| and disappears as soon as lapply() is done using it. So-called 'anonymous
| functions' can be very useful when one of R's built-in functions isn't an option.

...

  |========================================================================== |  98%

| In this lesson, you learned how to use the powerful lapply() and sapply()
| functions to apply an operation over the elements of a list. In the next lesson,
| we'll take a look at some close relatives of lapply() and sapply().

...

  |===========================================================================| 100%

| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 

Selection: 11

  |                                                                           |   0%

| In the last lesson, you learned about the two most fundamental members of R's
| *apply family of functions: lapply() and sapply(). Both take a list as input,
| apply a function to each element of the list, then combine and return the result.
| lapply() always returns a list, whereas sapply() attempts to simplify the result.

...

  |===                                                                        |   4%

| In this lesson, you'll learn how to use vapply() and tapply(), each of which
| serves a very specific purpose within the Split-Apply-Combine methodology. For
| consistency, we'll use the same dataset we used in the 'lapply and sapply' lesson.

...

  |======                                                                     |   8%

| The Flags dataset from the UCI Machine Learning Repository contains details of
| various nations and their flags. More information may be found here:
| http://archive.ics.uci.edu/ml/datasets/Flags

...

  |=========                                                                  |  12%

| I've stored the data in a variable called flags. If it's been a while since you
| completed the 'lapply and sapply' lesson, you may want to reacquaint yourself with
| the data by using functions like dim(), head(), str(), and summary() when you
| return to the prompt (>). You can also type viewinfo() at the prompt to bring up
| some documentation for the dataset. Let's get started!

...

  |============                                                               |  16%

| As you saw in the last lesson, the unique() function returns a vector of the
| unique values contained in the object passed to it. Therefore, sapply(flags,
| unique) returns a list containing one vector of unique values for each column of
| the flags dataset. Try it again now.

> sapply(flags, unique)
$name
  [1] Afghanistan              Albania                  Algeria                 
  [4] American-Samoa           Andorra                  Angola                  
  [7] Anguilla                 Antigua-Barbuda          Argentina               
 [10] Argentine                Australia                Austria                 
 [13] Bahamas                  Bahrain                  Bangladesh              
 [16] Barbados                 Belgium                  Belize                  
 [19] Benin                    Bermuda                  Bhutan                  
 [22] Bolivia                  Botswana                 Brazil                  
 [25] British-Virgin-Isles     Brunei                   Bulgaria                
 [28] Burkina                  Burma                    Burundi                 
 [31] Cameroon                 Canada                   Cape-Verde-Islands      
 [34] Cayman-Islands           Central-African-Republic Chad                    
 [37] Chile                    China                    Colombia                
 [40] Comorro-Islands          Congo                    Cook-Islands            
 [43] Costa-Rica               Cuba                     Cyprus                  
 [46] Czechoslovakia           Denmark                  Djibouti                
 [49] Dominica                 Dominican-Republic       Ecuador                 
 [52] Egypt                    El-Salvador              Equatorial-Guinea       
 [55] Ethiopia                 Faeroes                  Falklands-Malvinas      
 [58] Fiji                     Finland                  France                  
 [61] French-Guiana            French-Polynesia         Gabon                   
 [64] Gambia                   Germany-DDR              Germany-FRG             
 [67] Ghana                    Gibraltar                Greece                  
 [70] Greenland                Grenada                  Guam                    
 [73] Guatemala                Guinea                   Guinea-Bissau           
 [76] Guyana                   Haiti                    Honduras                
 [79] Hong-Kong                Hungary                  Iceland                 
 [82] India                    Indonesia                Iran                    
 [85] Iraq                     Ireland                  Israel                  
 [88] Italy                    Ivory-Coast              Jamaica                 
 [91] Japan                    Jordan                   Kampuchea               
 [94] Kenya                    Kiribati                 Kuwait                  
 [97] Laos                     Lebanon                  Lesotho                 
[100] Liberia                  Libya                    Liechtenstein           
[103] Luxembourg               Malagasy                 Malawi                  
[106] Malaysia                 Maldive-Islands          Mali                    
[109] Malta                    Marianas                 Mauritania              
[112] Mauritius                Mexico                   Micronesia              
[115] Monaco                   Mongolia                 Montserrat              
[118] Morocco                  Mozambique               Nauru                   
[121] Nepal                    Netherlands              Netherlands-Antilles    
[124] New-Zealand              Nicaragua                Niger                   
[127] Nigeria                  Niue                     North-Korea             
[130] North-Yemen              Norway                   Oman                    
[133] Pakistan                 Panama                   Papua-New-Guinea        
[136] Parguay                  Peru                     Philippines             
[139] Poland                   Portugal                 Puerto-Rico             
[142] Qatar                    Romania                  Rwanda                  
[145] San-Marino               Sao-Tome                 Saudi-Arabia            
[148] Senegal                  Seychelles               Sierra-Leone            
[151] Singapore                Soloman-Islands          Somalia                 
[154] South-Africa             South-Korea              South-Yemen             
[157] Spain                    Sri-Lanka                St-Helena               
[160] St-Kitts-Nevis           St-Lucia                 St-Vincent              
[163] Sudan                    Surinam                  Swaziland               
[166] Sweden                   Switzerland              Syria                   
[169] Taiwan                   Tanzania                 Thailand                
[172] Togo                     Tonga                    Trinidad-Tobago         
[175] Tunisia                  Turkey                   Turks-Cocos-Islands     
[178] Tuvalu                   UAE                      Uganda                  
[181] UK                       Uruguay                  US-Virgin-Isles         
[184] USA                      USSR                     Vanuatu                 
[187] Vatican-City             Venezuela                Vietnam                 
[190] Western-Samoa            Yugoslavia               Zaire                   
[193] Zambia                   Zimbabwe                
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola ... Zimbabwe

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31    23
 [14]   113    47  1099   600  8512     6   111   274   678    28   474  9976     4
 [27]   623  1284   757  9561  1139     2   342    51   115     9   128    43    22
 [40]    49   284  1001    21  1222    12    18   337   547    91   268    10   108
 [53]   249   239   132  2176   109   246    36   215   112    93   103  3268  1904
 [66]  1648   435    70   301   323    11   372    98   181   583   236    30  1760
 [79]     3   587   118   333  1240  1031  1973  1566   447   783   140    41  1267
 [92]   925   121   195   324   212   804    76   463   407  1285   300   313    92
[105]   237    26  2150   196    72   637  1221    99   288   505    66  2506    63
[118]    17   450   185   945   514    57     5   164   781   245   178  9363 22402
[131]    15   912   256   905   753   391

$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9   35    4
[17]   24    2   11 1008    5   47   31   54   17   61   14  684  157   39   57  118
[33]   13   77   12   56   18   84   48   36   22   29   38   49   45  231  274   60

$language
 [1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] green  red    blue   gold   white  orange black  brown 
Levels: black blue brown gold green orange red white

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] black  red    green  blue   white  orange gold  
Levels: black blue gold green orange red white

$botright
[1] green  red    white  black  blue   gold   orange brown 
Levels: black blue brown gold green orange red white


| Your dedication is inspiring!

  |===============                                                            |  20%

| What if you had forgotten how unique() works and mistakenly thought it returns the
| *number* of unique values contained in the object passed to it? Then you might
| have incorrectly expected sapply(flags, unique) to return a numeric vector, since
| each element of the list returned would contain a single number and sapply() could
| then simplify the result to a vector.

...

  |==================                                                         |  24%

| When working interactively (at the prompt), this is not much of a problem, since
| you see the result immediately and will quickly recognize your mistake. However,
| when working non-interactively (e.g. writing your own functions), a
| misunderstanding may go undetected and cause incorrect results later on.
| Therefore, you may wish to be more careful and that's where vapply() is useful.

...

  |=====================                                                      |  28%

| Whereas sapply() tries to 'guess' the correct format of the result, vapply()
| allows you to specify it explicitly. If the result doesn't match the format you
| specify, vapply() will throw an error, causing the operation to stop. This can
| prevent significant problems in your code that might be caused by getting
| unexpected return values from sapply().

...

  |========================                                                   |  32%

| Try vapply(flags, unique, numeric(1)), which says that you expect each element of
| the result to be a numeric vector of length 1. Since this is NOT actually the
| case, YOU WILL GET AN ERROR. Once you get the error, type ok() to continue to the
| next question.

> vapply(flags, unique, numeric(1))
Error in vapply(flags, unique, numeric(1)) : values must be length 1,
 but FUN(X[[1]]) result is length 194
> ok()

| All that hard work is paying off!

  |===========================                                                |  36%

| Recall from the previous lesson that sapply(flags, class) will return a character
| vector containing the class of each column in the dataset. Try that again now to
| see the result.

> sapply(flags, class)
      name   landmass       zone       area population   language   religion 
  "factor"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
      bars    stripes    colours        red      green       blue       gold 
 "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
     white      black     orange    mainhue    circles    crosses   saltires 
 "integer"  "integer"  "integer"   "factor"  "integer"  "integer"  "integer" 
  quarters   sunstars   crescent   triangle       icon    animate       text 
 "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
   topleft   botright 
  "factor"   "factor" 

| Keep up the great work!

  |==============================                                             |  40%

| If we wish to be explicit about the format of the result we expect, we can use
| vapply(flags, class, character(1)). The 'character(1)' argument tells R that we
| expect the class function to return a character vector of length 1 when applied to
| EACH column of the flags dataset. Try it now.

> vapply(flags, class, character(1))
      name   landmass       zone       area population   language   religion 
  "factor"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
      bars    stripes    colours        red      green       blue       gold 
 "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
     white      black     orange    mainhue    circles    crosses   saltires 
 "integer"  "integer"  "integer"   "factor"  "integer"  "integer"  "integer" 
  quarters   sunstars   crescent   triangle       icon    animate       text 
 "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
   topleft   botright 
  "factor"   "factor" 

| You nailed it! Good job!

  |=================================                                          |  44%

| Note that since our expectation was correct (i.e. character(1)), the vapply()
| result is identical to the sapply() result -- a character vector of column
| classes.

...

  |====================================                                       |  48%

| You might think of vapply() as being 'safer' than sapply(), since it requires you
| to specify the format of the output in advance, instead of just allowing R to
| 'guess' what you wanted. In addition, vapply() may perform faster than sapply()
| for large datasets. However, when doing data analysis interactively (at the
| prompt), sapply() saves you some typing and will often be good enough.

...

  |=======================================                                    |  52%

| As a data analyst, you'll often wish to split your data up into groups based on
| the value of some variable, then apply a function to the members of each group.
| The next function we'll look at, tapply(), does exactly that.

...

  |==========================================                                 |  56%

| Use ?tapply to pull up the documentation.

> ?tapply

| Your dedication is inspiring!

  |=============================================                              |  60%

| The 'landmass' variable in our dataset takes on integer values between 1 and 6,
| each of which represents a different part of the world. Use table(flags$landmass)
| to see how many flags/countries fall into each group.

> table(flags$landmass)

 1  2  3  4  5  6 
31 17 35 52 39 20 

| All that hard work is paying off!

  |================================================                           |  64%

| The 'animate' variable in our dataset takes the value 1 if a country's flag
| contains an animate image (e.g. an eagle, a tree, a human hand) and 0 otherwise.
| Use table(flags$animate) to see how many flags contain an animate image.

> table(flags$animate)

  0   1 
155  39 

| Excellent job!

  |===================================================                        |  68%

| This tells us that 39 flags contain an animate object (animate = 1) and 155 do not
| (animate = 0).

...

  |======================================================                     |  72%

| If you take the arithmetic mean of a bunch of 0s and 1s, you get the proportion of
| 1s. Use tapply(flags$animate, flags$landmass, mean) to apply the mean function to
| the 'animate' variable separately for each of the six landmass groups, thus giving
| us the proportion of flags containing an animate image WITHIN each landmass group.

> tapply(flags$landmass, mean)
Error in unique.default(x, nmax = nmax) : 
  unique() applies only to vectors
> tapply(flags$animate, flags$landmass, mean)
        1         2         3         4         5         6 
0.4193548 0.1764706 0.1142857 0.1346154 0.1538462 0.3000000 

| Excellent job!

  |=========================================================                  |  76%

| The first landmass group (landmass = 1) corresponds to North America and contains
| the highest proportion of flags with an animate image (0.4194).

...

  |============================================================               |  80%

| Similarly, we can look at a summary of population values (in round millions) for
| countries with and without the color red on their flag with
| tapply(flags$population, flags$red, summary).

> tapply(flags$population, flags$red, summary)
$`0`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    3.00   27.63    9.00  684.00 

$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    0.0     0.0     4.0    22.1    15.0  1008.0 


| Excellent work!

  |===============================================================            |  84%

| What is the median population (in millions) for countries *without* the color red
| on their flag?

1: 22.1
2: 4.0
3: 3.0
4: 0.0
5: 27.6
6: 9.0

Selection: 5

| Keep trying!

| Use your result from the last question. Recall that red = 0 means that the color
| red is NOT present on a countries flag.

1: 4.0
2: 27.6
3: 0.0
4: 22.1
5: 3.0
6: 9.0

Selection: 5

| Keep up the great work!

  |==================================================================         |  88%

| Lastly, use the same approach to look at a summary of population values for each
| of the six landmasses.

> tapply(flags$landmass, flags$red, summary)
$`0`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   2.000   4.000   3.293   5.000   6.000 

$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   3.000   4.000   3.647   5.000   6.000 


| Not quite, but you're learning! Try again. Or, type info() for more options.

| You can see a summary of populations for each of the six landmasses by calling
| tapply() with three arguments: flags$population, flags$landmass, and summary.

> tapply(flags$landmass, flags$population, summary)
$`0`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   1.000   3.000   3.321   5.250   6.000 

$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    2.0     4.0     4.0     4.0     4.5     6.0 

$`2`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   3.500   4.000   3.833   5.000   6.000 

$`3`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   2.000   4.000   3.462   5.000   6.000 

$`4`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    1.0     3.0     4.0     3.4     4.0     5.0 

$`5`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   3.000   4.000   3.429   4.000   5.000 

$`6`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   2.000   4.000   3.111   4.000   5.000 

$`7`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`8`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   2.250   3.000   2.833   3.750   4.000 

$`9`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   3.00    3.75    4.50    4.25    5.00    5.00 

$`10`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      1       3       3       3       3       5 

$`11`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   2.00    2.25    2.50    2.50    2.75    3.00 

$`12`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`13`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   4.00    4.25    4.50    4.50    4.75    5.00 

$`14`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   2.00    2.75    3.50    3.50    4.25    5.00 

$`15`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   2.00    2.75    4.00    4.00    5.25    6.00 

$`16`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`17`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   3.00    3.25    3.50    3.50    3.75    4.00 

$`18`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  4.000   4.500   5.000   4.667   5.000   5.000 

$`20`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`22`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`24`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      1       1       1       1       1       1 

$`28`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    2.0     2.0     2.0     2.5     2.5     4.0 

$`29`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`31`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`35`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`36`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`38`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`39`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`45`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`47`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`48`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      6       6       6       6       6       6 

$`49`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`54`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`56`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   3.00    3.25    3.50    3.50    3.75    4.00 

$`57`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`60`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`61`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`77`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      1       1       1       1       1       1 

$`84`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`90`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`118`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`119`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      2       2       2       2       2       2 

$`157`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      6       6       6       6       6       6 

$`231`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      1       1       1       1       1       1 

$`274`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`684`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`1008`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 


| Not quite right, but keep trying. Or, type info() for more options.

| You can see a summary of populations for each of the six landmasses by calling
| tapply() with three arguments: flags$population, flags$landmass, and summary.

> tapply( flags$population, flags$landmass, summary)
$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    0.00   12.29    4.50  231.00 

$`2`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    1.00    6.00   15.71   15.00  119.00 

$`3`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    8.00   13.86   16.00   61.00 

$`4`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  0.000   1.000   5.000   8.788   9.750  56.000 

$`5`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    2.00   10.00   69.18   39.00 1008.00 

$`6`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    0.00   11.30    1.25  157.00 


| Keep up the great work!

  |=====================================================================      |  92%

| What is the maximum population (in millions) for the fourth landmass group
| (Africa)?

1: 119.0
2: 5.00
3: 1010.0
4: 157.00
5: 56.00

Selection: 5

| You got it!

  |========================================================================   |  96%

| In this lesson, you learned how to use vapply() as a safer alternative to
| sapply(), which is most helpful when writing your own functions. You also learned
| how to use tapply() to split your data into groups based on the value of some
| variable, then apply a function to each group. These functions will come in handy
| on your quest to become a better data analyst.

...

  |===========================================================================| 100%
  